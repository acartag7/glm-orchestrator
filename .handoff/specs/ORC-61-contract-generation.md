# ORC-61: Contract Generation System

## Overview

Implement a contract generation phase in Spec Studio that produces explicit, typed contracts from natural language specs before chunking. Contracts define exactly what will be created (types, files, functions, signatures) and how chunks depend on each other.

## Problem Statement

Current chunking is vague:
- Chunks have titles and descriptions but no explicit contracts
- No definition of what each chunk creates vs consumes
- No explicit dependencies between chunks
- GLM must guess what exists, leading to broken imports

## Solution

Add a **Contract Phase** between spec refinement and chunking:

```
Spec Writing â†’ Spec Refinement â†’ CONTRACT GENERATION â†’ Feasibility Check â†’ User Review â†’ Chunking â†’ Execution
                                        â†‘                      â†‘              â†‘
                                   NEW PHASE            VALIDATES        USER APPROVAL
```

---

# MVP vs Roadmap

## MVP Scope

| Feature | Description | Priority |
|---------|-------------|----------|
| SpecContract type | Core data model with types, files, chunks, creates/consumes | P0 |
| Contract generation prompt | Opus generates contract from spec | P0 |
| Feasibility check (grep) | Validate consumes exist in repo before user review | P0 |
| Basic contract review UI | Show types, files, chunks in readable format | P0 |
| Contract approval flow | Approve â†’ generate chunks with dependencies | P0 |
| Inline warnings | Show feasibility issues in review UI | P0 |

## Roadmap (Post-MVP)

| Feature | Description | Priority |
|---------|-------------|----------|
| Contract editing UI | Full CRUD for types, files, chunks | P1 |
| Dependency graph visualization | Visual DAG of chunk dependencies | P1 |
| Progressive disclosure | Collapsed defaults, expand for details | P1 |
| Smart warnings | Highlight unusual patterns vs standard | P2 |
| Contract templates | Reusable patterns for common features | P2 |
| Contract diffing | Show what changed on regenerate | P2 |
| Import from previous specs | Copy/adapt contracts from similar work | P3 |
| Contract versioning | Track iterations of contract design | P3 |

---

# Data Model

## Unified Resource Model

The contract system uses a **unified resource type** with discriminated unions based on lifecycle phase. This enables type-safe transitions from planning â†’ creation â†’ availability.

```typescript
// ============================================
// RESOURCE LIFECYCLE (State Pattern)
// ============================================

/**
 * Resource lifecycle phases:
 * - planned: Contract says this WILL be created
 * - created: Execution produced this (pre-validation)
 * - available: Validated and ready for subsequent steps
 */
type ResourcePhase = 'planned' | 'created' | 'available';

/**
 * Resource types supported by the system.
 * Extensible for protocol-specific types.
 */
type ResourceType = 'file' | 'data' | 'message' | 'artifact' | string;

/**
 * Base fields shared across all resource phases.
 */
interface ResourceBase {
  id: string;                          // Unique identifier
  type: ResourceType;                  // file, data, message, artifact, etc.
  location?: string;                   // Path, URL, or key
  format?: string;                     // typescript, json, text, etc.
  metadata?: Record<string, unknown>;  // Protocol-specific extensions
}

// ============================================
// PHASE-SPECIFIC RESOURCE TYPES
// ============================================

/**
 * PlannedResource: What the contract says WILL be created.
 * Generated during contract generation phase.
 */
interface PlannedResource extends ResourceBase {
  phase: 'planned';

  // Planning-specific fields (rich detail for LLM context)
  definition?: string;                 // Full TypeScript definition
  signature?: string;                  // Function signature
  exports?: string[];                  // What this file will export
  imports?: { from: string; items: string[] }[];
  action?: 'create' | 'modify';
  purpose?: string;                    // Why this resource exists
  exportedFrom?: string;               // Package export path

  // Optional: Default validator for this resource
  validator?: string;
}

/**
 * CreatedResource: What WAS created (post-execution, pre-validation).
 * Generated by ContextAccumulator from git diff.
 */
interface CreatedResource extends ResourceBase {
  phase: 'created';

  // Execution-specific fields
  createdByStep: string;               // Step ID that created this
  createdAt: string;                   // ISO timestamp
  actualExports?: string[];            // What was actually exported
  actualLocation?: string;             // Where it ended up (may differ from planned)
}

/**
 * AvailableResource: Validated and ready for subsequent steps.
 * Promoted from CreatedResource after validation passes.
 */
interface AvailableResource extends ResourceBase {
  phase: 'available';

  // Availability-specific fields
  exportName: string;                  // What to import
  exportType: 'type' | 'interface' | 'function' | 'const' | 'class';
  importFrom: string;                  // Import path ("@specwright/shared")
  providedByStep: string;              // Step that provides this
  verifiedAt: string;                  // When validation passed
}

/**
 * Discriminated union of all resource phases.
 * TypeScript enforces correct field access based on phase.
 */
type ContractResource = PlannedResource | CreatedResource | AvailableResource;

// ============================================
// TYPE GUARDS
// ============================================

function isPlanned(r: ContractResource): r is PlannedResource {
  return r.phase === 'planned';
}

function isCreated(r: ContractResource): r is CreatedResource {
  return r.phase === 'created';
}

function isAvailable(r: ContractResource): r is AvailableResource {
  return r.phase === 'available';
}

// ============================================
// PHASE TRANSITIONS
// ============================================

/**
 * Promote a created resource to available after validation.
 */
function promoteToAvailable(
  created: CreatedResource,
  exportInfo: { name: string; type: string; importFrom: string }
): AvailableResource {
  return {
    id: created.id,
    type: created.type,
    location: created.actualLocation || created.location,
    format: created.format,
    metadata: created.metadata,
    phase: 'available',
    exportName: exportInfo.name,
    exportType: exportInfo.type as AvailableResource['exportType'],
    importFrom: exportInfo.importFrom,
    providedByStep: created.createdByStep,
    verifiedAt: new Date().toISOString()
  };
}
```

## Core Contract Types

```typescript
// ============================================
// ASSERTION TYPES (with Hybrid Validator Selection)
// ============================================

/**
 * Assertion check types - what kind of validation to perform.
 */
type AssertionCheckType =
  // File-based checks
  | 'export_exists'        // File export exists
  | 'file_exists'          // File exists
  | 'function_exists'      // Function exists
  | 'signature_match'      // Function signature matches
  | 'pattern_match'        // Regex pattern match
  | 'type_matches'         // Type shape matches (roadmap)
  // Generic checks
  | 'exists'               // Resource exists (any type)
  | 'schema_match'         // Matches JSON schema
  | 'http_status'          // HTTP endpoint returns status
  | 'contains'             // Resource contains value
  | 'equals'               // Resource equals value
  | 'custom';              // Custom validator

/**
 * JSON Schema type for data validation.
 */
interface JSONSchema {
  type?: string;
  properties?: Record<string, JSONSchema>;
  required?: string[];
  items?: JSONSchema;
  [key: string]: unknown;
}

/**
 * Assertion for a step - DSPy-inspired Assert/Suggest pattern.
 * Supports hybrid validator selection (auto + explicit override).
 */
interface ContractAssertion {
  type: 'assert' | 'suggest';
  condition: string;                   // Human-readable condition
  message: string;                     // Error message if violated

  check: {
    type: AssertionCheckType;
    target: string;                    // Resource ID to check

    // Hybrid validator selection (optional override)
    validator?: string;                // Override auto-selection

    // Check-specific fields
    file?: string;                     // File path (for file checks)
    expected?: string;                 // Expected value
    pattern?: string;                  // Regex pattern
    schema?: JSONSchema;               // JSON schema

    // HTTP checks
    method?: string;
    headers?: Record<string, string>;
    expectedStatus?: number;
  };
}

// ============================================
// VALIDATOR CONFIGURATION
// ============================================

/**
 * Validator configuration for the contract.
 * Defines which validators are available and auto-selection rules.
 */
interface ValidatorConfig {
  type: string;                        // "file-export", "json-schema", etc.
  resourceTypes: string[];             // Which resource types this handles
  options?: Record<string, unknown>;   // Validator-specific options

  // Auto-selection rules
  autoSelect?: {
    formats?: string[];                // Auto-select for these formats
    conditions?: string;               // Future: expression-based selection
  };
}

// ============================================
// CONTRACT STEP (formerly ContractChunk)
// ============================================

/**
 * A single step in the contract execution.
 * Uses resource IDs for creates/consumes (not string descriptions).
 */
interface ContractStep {
  id: string;
  order: number;
  title: string;
  description: string;

  // Resource references (by ID)
  creates: string[];                   // Resource IDs this step creates
  consumes: string[];                  // Resource IDs this step needs
  dependsOn: string[];                 // Step IDs that must complete first

  // Assertions for this step
  assertions: ContractAssertion[];

  // Execution metadata
  agent?: string;                      // Who executes (opencode, claude-code)
  timeout?: number;                    // Max execution time (ms)
  retries?: number;                    // Max retry attempts
}

// ============================================
// FEASIBILITY CHECK
// ============================================

/**
 * Feasibility check result for a single item.
 */
interface FeasibilityIssue {
  severity: 'error' | 'warning';
  category: 'consumes' | 'file_path' | 'import' | 'conflict' | 'validator';
  resourceId: string;                  // Which resource has the issue
  message: string;                     // What's wrong
  suggestion?: string;                 // How to fix
}

/**
 * Full feasibility check result.
 */
interface FeasibilityResult {
  feasible: boolean;                   // No errors (warnings OK)
  issues: FeasibilityIssue[];
  checkedAt: string;                   // ISO timestamp
}

// ============================================
// SPEC CONTRACT (Top-Level)
// ============================================

/**
 * Full specification contract.
 * Contains all planned resources, steps, and validation config.
 */
interface SpecContract {
  version: string;                     // Contract schema version "1.0"
  specId: string;
  generatedAt: string;                 // ISO timestamp

  // All resources (all in 'planned' phase initially)
  resources: PlannedResource[];

  // Execution steps
  steps: ContractStep[];

  // Global assertions (apply to all steps)
  globalAssertions: ContractAssertion[];

  // Validator configuration (for hybrid selection)
  validators: ValidatorConfig[];

  // Feasibility check result (populated after check)
  feasibility?: FeasibilityResult;

  // Metadata
  metadata?: {
    specTitle?: string;
    generatedBy?: string;
    [key: string]: unknown;
  };
}

// ============================================
// CONTRACT AMENDMENT (Roadmap)
// ============================================

/**
 * Contract amendment proposal.
 * Used when execution discovers the contract needs changes.
 */
interface ContractAmendment {
  id: string;
  contractId: string;
  proposedBy: 'system' | 'user';
  reason: string;
  changes: {
    path: string;                      // "resources[2].definition"
    oldValue: unknown;
    newValue: unknown;
  }[];
  affectedSteps: string[];             // Step IDs affected
  status: 'pending' | 'accepted' | 'rejected';
  createdAt: string;
}
```

## Validator Selection (Hybrid Model)

Validators are selected using a resolution chain (most specific wins):

```
1. Assertion-level override  â†’  check.validator: "file-ast"
2. Resource-level default    â†’  resource.validator: "json-schema"
3. Auto-detection            â†’  infer from resource.type + resource.format
4. Contract-level fallback   â†’  contract.validators[].resourceTypes
```

### Default Auto-Selection Rules

| Resource Type | Format | Default Validator |
|--------------|--------|-------------------|
| `file` | `typescript`, `javascript` | `file-export` |
| `file` | `json` | `json-schema` |
| `data` | `json` | `json-schema` |
| `message` | any | `json-schema` |
| `api`, `endpoint` | any | `http` |
| any | any | `exists` (fallback) |

### Example Contract with Validators

```typescript
const contract: SpecContract = {
  version: '1.0',
  specId: 'spec_health_check',
  generatedAt: '2024-01-15T10:00:00Z',

  resources: [
    {
      id: 'res_health_check_type',
      phase: 'planned',
      type: 'file',
      format: 'typescript',
      location: 'packages/shared/src/types.ts',
      definition: 'interface HealthCheckResult { ... }',
      exportedFrom: '@specwright/shared',
      // No validator â†’ auto-selects 'file-export'
    },
    {
      id: 'res_health_endpoint',
      phase: 'planned',
      type: 'endpoint',
      format: 'json',
      location: 'http://localhost:4096/health',
      validator: 'http',  // Explicit override
    }
  ],

  steps: [
    {
      id: 'step_1',
      order: 1,
      title: 'Create health check types',
      description: 'Define HealthCheckResult interface',
      creates: ['res_health_check_type'],
      consumes: [],
      dependsOn: [],
      assertions: [
        {
          type: 'assert',
          condition: 'HealthCheckResult exported',
          message: 'Must export HealthCheckResult',
          check: {
            type: 'export_exists',
            target: 'res_health_check_type',
            // No validator override â†’ uses resource default â†’ auto-selects
          }
        },
        {
          type: 'assert',
          condition: 'Signature matches',
          message: 'checkHealth must have correct signature',
          check: {
            type: 'signature_match',
            target: 'res_health_check_fn',
            validator: 'file-ast',  // Override: need AST for signatures
            expected: '(): Promise<HealthCheckResult>'
          }
        }
      ]
    }
  ],

  globalAssertions: [],

  validators: [
    {
      type: 'file-export',
      resourceTypes: ['file'],
      autoSelect: { formats: ['typescript', 'javascript'] }
    },
    {
      type: 'json-schema',
      resourceTypes: ['data', 'message'],
      autoSelect: { formats: ['json'] }
    },
    {
      type: 'http',
      resourceTypes: ['api', 'endpoint']
    },
    {
      type: 'exists',
      resourceTypes: ['*']  // Fallback for everything
    }
  ]
};
```

## Database Changes

```sql
-- Add contract column to specs
ALTER TABLE specs ADD COLUMN contract TEXT;  -- JSON serialized SpecContract
ALTER TABLE specs ADD COLUMN contract_approved_at TEXT;

-- Add contract fields to chunks
ALTER TABLE chunks ADD COLUMN creates TEXT;      -- JSON array
ALTER TABLE chunks ADD COLUMN consumes TEXT;     -- JSON array
ALTER TABLE chunks ADD COLUMN depends_on TEXT;   -- JSON array of chunk IDs
ALTER TABLE chunks ADD COLUMN assertions TEXT;   -- JSON array

-- Roadmap: Contract amendments table
CREATE TABLE IF NOT EXISTS contract_amendments (
  id TEXT PRIMARY KEY,
  spec_id TEXT NOT NULL,
  proposed_by TEXT NOT NULL,
  reason TEXT NOT NULL,
  changes TEXT NOT NULL,        -- JSON
  affected_chunks TEXT NOT NULL, -- JSON array
  status TEXT DEFAULT 'pending',
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  resolved_at TEXT,
  FOREIGN KEY (spec_id) REFERENCES specs(id)
);
```

---

# MVP Implementation

## 1. Contract Generation Prompt

```typescript
// packages/dashboard/src/prompts/contract-generator.ts

export const CONTRACT_GENERATION_SYSTEM = `You are a software architect generating implementation contracts.

Your job is to analyze a specification and produce a detailed contract that defines:
1. Exactly what types/interfaces will be created
2. Exactly what files will be created or modified
3. Exactly what functions will be implemented
4. How the work is divided into ordered chunks with dependencies

RULES:
- Every type must have a complete TypeScript definition
- Every file must list its exports and imports
- Every function must have a complete signature with parameters and return type
- Chunks must be ordered so dependencies come first
- Each chunk's consumes[] must only reference items from previous chunks' creates[] OR existing project exports
- Never create circular dependencies
- Prefer modifying existing files over creating new ones
- Use existing project patterns and conventions

ASSERTIONS:
For each chunk, include assertions that can be verified:
- ASSERT (hard requirement): "File must export X", "Function must return Promise<Y>"
- SUGGEST (soft guidance): "Should follow existing patterns", "Prefer using existing component"`;

export const CONTRACT_GENERATION_USER = `
SPECIFICATION:
{spec_content}

PROJECT CONTEXT:
Working directory: {working_dir}
Existing exports from @specwright/shared:
{existing_shared_exports}

Existing project files:
{existing_files_summary}

Generate a complete implementation contract as JSON matching this schema:
{contract_schema}

Return ONLY valid JSON, no markdown code blocks or explanation.`;
```

## 2. Feasibility Check Service

```typescript
// packages/dashboard/src/lib/services/feasibility-checker.ts

import { spawnSync } from 'child_process';
import * as path from 'path';

export class FeasibilityChecker {
  constructor(private workingDir: string) {}

  async check(contract: SpecContract): Promise<FeasibilityResult> {
    const issues: FeasibilityIssue[] = [];

    // 1. Check all consumes items exist
    for (const chunk of contract.chunks) {
      for (const item of chunk.consumes) {
        const exists = await this.checkItemExists(item, contract, chunk.order);
        if (!exists.found) {
          issues.push({
            severity: 'error',
            category: 'consumes',
            item,
            message: `"${item}" not found in project or previous chunks`,
            suggestion: exists.suggestion,
            location: `chunks[${chunk.order}].consumes`
          });
        }
      }
    }

    // 2. Check file paths are valid
    for (const file of contract.files) {
      if (file.action === 'modify') {
        const exists = await this.fileExists(file.path);
        if (!exists) {
          issues.push({
            severity: 'error',
            category: 'file_path',
            item: file.path,
            message: `Cannot modify "${file.path}" - file does not exist`,
            suggestion: 'Change action to "create" or fix the path',
            location: `files[${file.path}]`
          });
        }
      }
      if (file.action === 'create') {
        const exists = await this.fileExists(file.path);
        if (exists) {
          issues.push({
            severity: 'warning',
            category: 'file_path',
            item: file.path,
            message: `File "${file.path}" already exists - will be overwritten`,
            suggestion: 'Change action to "modify" if extending existing file',
            location: `files[${file.path}]`
          });
        }
      }
    }

    // 3. Check imports reference valid packages
    for (const file of contract.files) {
      for (const imp of file.imports) {
        const valid = await this.checkImportValid(imp.from);
        if (!valid) {
          issues.push({
            severity: 'warning',
            category: 'import',
            item: `${imp.from}`,
            message: `Import from "${imp.from}" may not exist`,
            location: `files[${file.path}].imports`
          });
        }
      }
    }

    // 4. Check for dependency order violations
    const orderIssues = this.checkDependencyOrder(contract);
    issues.push(...orderIssues);

    // 5. Check for name conflicts
    const conflictIssues = this.checkNameConflicts(contract);
    issues.push(...conflictIssues);

    return {
      feasible: !issues.some(i => i.severity === 'error'),
      issues,
      checkedAt: new Date().toISOString()
    };
  }

  private async checkItemExists(
    item: string,
    contract: SpecContract,
    beforeOrder: number
  ): Promise<{ found: boolean; suggestion?: string }> {
    // Check if created by a previous chunk
    const createdBefore = contract.chunks
      .filter(c => c.order < beforeOrder)
      .some(c => c.creates.includes(item));

    if (createdBefore) {
      return { found: true };
    }

    // Check if exists in project using grep
    const grepResult = this.grepForExport(item);
    if (grepResult.found) {
      return { found: true };
    }

    // Try to find similar names for suggestion
    const similar = this.findSimilarExports(item);
    return {
      found: false,
      suggestion: similar ? `Did you mean: ${similar}?` : undefined
    };
  }

  private grepForExport(name: string): { found: boolean; file?: string } {
    // Simple grep for export
    const pattern = `export.*(const|function|interface|type|class)\\s+${name}\\b`;
    const result = spawnSync('grep', ['-r', '-l', '-E', pattern, '.'], {
      cwd: this.workingDir,
      encoding: 'utf-8',
      shell: false
    });

    if (result.status === 0 && result.stdout.trim()) {
      return { found: true, file: result.stdout.trim().split('\n')[0] };
    }

    // Also check for re-exports
    const reexportPattern = `export\\s*\\{[^}]*${name}[^}]*\\}`;
    const reexportResult = spawnSync('grep', ['-r', '-l', '-E', reexportPattern, '.'], {
      cwd: this.workingDir,
      encoding: 'utf-8',
      shell: false
    });

    if (reexportResult.status === 0 && reexportResult.stdout.trim()) {
      return { found: true, file: reexportResult.stdout.trim().split('\n')[0] };
    }

    return { found: false };
  }

  private findSimilarExports(name: string): string | undefined {
    // Simple Levenshtein-ish search for similar names
    // Could be improved with proper fuzzy matching
    const prefix = name.slice(0, 3).toLowerCase();
    const result = spawnSync('grep', ['-r', '-h', '-o', '-E',
      `export\\s+(const|function|interface|type|class)\\s+${prefix}\\w+`
    ], {
      cwd: this.workingDir,
      encoding: 'utf-8',
      shell: false
    });

    if (result.status === 0 && result.stdout.trim()) {
      const matches = result.stdout.trim().split('\n')
        .map(line => line.match(/\s(\w+)$/)?.[1])
        .filter(Boolean);
      return matches[0];
    }
    return undefined;
  }

  private async fileExists(filePath: string): Promise<boolean> {
    const fullPath = path.join(this.workingDir, filePath);
    try {
      await fs.access(fullPath);
      return true;
    } catch {
      return false;
    }
  }

  private checkImportValid(importPath: string): boolean {
    // Check if it's a known package or relative import
    if (importPath.startsWith('.') || importPath.startsWith('/')) {
      return true; // Relative imports - can't validate without more context
    }
    if (importPath.startsWith('@specwright/')) {
      return true; // Our packages
    }
    // Check node_modules
    const packageName = importPath.split('/')[0];
    const packagePath = path.join(this.workingDir, 'node_modules', packageName);
    try {
      fs.accessSync(packagePath);
      return true;
    } catch {
      return false;
    }
  }

  private checkDependencyOrder(contract: SpecContract): FeasibilityIssue[] {
    const issues: FeasibilityIssue[] = [];

    for (const chunk of contract.chunks) {
      for (const depOrder of chunk.dependsOn) {
        if (depOrder >= chunk.order) {
          issues.push({
            severity: 'error',
            category: 'conflict',
            item: `Chunk ${chunk.order}`,
            message: `Depends on chunk ${depOrder} which comes after or is same`,
            location: `chunks[${chunk.order}].dependsOn`
          });
        }
      }
    }

    // Check for cycles
    const visited = new Set<number>();
    const recursionStack = new Set<number>();

    const hasCycle = (order: number): boolean => {
      visited.add(order);
      recursionStack.add(order);

      const chunk = contract.chunks.find(c => c.order === order);
      if (chunk) {
        for (const dep of chunk.dependsOn) {
          if (!visited.has(dep) && hasCycle(dep)) {
            return true;
          } else if (recursionStack.has(dep)) {
            return true;
          }
        }
      }

      recursionStack.delete(order);
      return false;
    };

    for (const chunk of contract.chunks) {
      if (!visited.has(chunk.order) && hasCycle(chunk.order)) {
        issues.push({
          severity: 'error',
          category: 'conflict',
          item: `Chunk ${chunk.order}`,
          message: 'Circular dependency detected',
          location: `chunks[${chunk.order}]`
        });
        break;
      }
    }

    return issues;
  }

  private checkNameConflicts(contract: SpecContract): FeasibilityIssue[] {
    const issues: FeasibilityIssue[] = [];
    const names = new Map<string, string>();

    // Check type names
    for (const type of contract.types) {
      if (names.has(type.name)) {
        issues.push({
          severity: 'error',
          category: 'conflict',
          item: type.name,
          message: `Type "${type.name}" defined multiple times`,
          location: `types`
        });
      }
      names.set(type.name, 'type');
    }

    // Check function names
    for (const func of contract.functions) {
      if (names.has(func.name)) {
        issues.push({
          severity: 'warning',
          category: 'conflict',
          item: func.name,
          message: `"${func.name}" conflicts with existing ${names.get(func.name)}`,
          location: `functions`
        });
      }
      names.set(func.name, 'function');
    }

    return issues;
  }
}
```

## 3. Contract Review UI (MVP)

```typescript
// packages/dashboard/src/components/spec-studio/ContractReviewStep.tsx

interface Props {
  contract: SpecContract;
  onApprove: () => void;
  onRegenerate: () => void;
  onBack: () => void;
}

export function ContractReviewStep({ contract, onApprove, onRegenerate, onBack }: Props) {
  const hasErrors = contract.feasibility?.issues.some(i => i.severity === 'error');
  const warnings = contract.feasibility?.issues.filter(i => i.severity === 'warning') || [];
  const errors = contract.feasibility?.issues.filter(i => i.severity === 'error') || [];

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold text-white">Review Contract</h2>
        <button
          onClick={onRegenerate}
          className="px-3 py-1.5 text-sm bg-neutral-800 hover:bg-neutral-700 rounded"
        >
          Regenerate
        </button>
      </div>

      {/* Feasibility Issues */}
      {(errors.length > 0 || warnings.length > 0) && (
        <div className="space-y-2">
          {errors.map((issue, i) => (
            <div key={i} className="p-3 bg-red-500/10 border border-red-500/30 rounded-lg">
              <div className="flex items-center gap-2">
                <XCircle className="w-4 h-4 text-red-400" />
                <span className="text-sm font-medium text-red-300">{issue.item}</span>
              </div>
              <p className="text-sm text-red-200 mt-1">{issue.message}</p>
              {issue.suggestion && (
                <p className="text-xs text-red-300/70 mt-1">ğŸ’¡ {issue.suggestion}</p>
              )}
            </div>
          ))}
          {warnings.map((issue, i) => (
            <div key={i} className="p-3 bg-yellow-500/10 border border-yellow-500/30 rounded-lg">
              <div className="flex items-center gap-2">
                <AlertTriangle className="w-4 h-4 text-yellow-400" />
                <span className="text-sm font-medium text-yellow-300">{issue.item}</span>
              </div>
              <p className="text-sm text-yellow-200 mt-1">{issue.message}</p>
              {issue.suggestion && (
                <p className="text-xs text-yellow-300/70 mt-1">ğŸ’¡ {issue.suggestion}</p>
              )}
            </div>
          ))}
        </div>
      )}

      {/* Types Section */}
      <CollapsibleSection
        title={`Types (${contract.types.length})`}
        defaultOpen={contract.types.length <= 3}
      >
        <div className="space-y-2">
          {contract.types.map((type, i) => (
            <div key={i} className="p-3 bg-neutral-800/50 rounded-lg">
              <div className="flex items-center justify-between">
                <span className="font-mono text-sm text-emerald-400">{type.name}</span>
                <span className="text-xs text-neutral-500">{type.exportedFrom}</span>
              </div>
              <pre className="mt-2 text-xs text-neutral-300 overflow-x-auto">
                {type.definition}
              </pre>
            </div>
          ))}
        </div>
      </CollapsibleSection>

      {/* Files Section */}
      <CollapsibleSection
        title={`Files (${contract.files.length})`}
        defaultOpen={contract.files.length <= 5}
      >
        <div className="space-y-2">
          {contract.files.map((file, i) => (
            <div key={i} className="p-3 bg-neutral-800/50 rounded-lg">
              <div className="flex items-center gap-2">
                <span className={`text-xs px-1.5 py-0.5 rounded ${
                  file.action === 'create'
                    ? 'bg-emerald-500/20 text-emerald-400'
                    : 'bg-blue-500/20 text-blue-400'
                }`}>
                  {file.action.toUpperCase()}
                </span>
                <span className="font-mono text-sm text-neutral-300">{file.path}</span>
              </div>
              <p className="text-xs text-neutral-500 mt-1">{file.purpose}</p>
              <div className="mt-2 text-xs">
                <span className="text-neutral-500">Exports: </span>
                <span className="text-neutral-300">{file.exports.join(', ')}</span>
              </div>
            </div>
          ))}
        </div>
      </CollapsibleSection>

      {/* Chunks Section */}
      <CollapsibleSection title={`Chunks (${contract.chunks.length})`} defaultOpen>
        <div className="space-y-3">
          {contract.chunks.map((chunk, i) => (
            <div key={i} className="p-4 bg-neutral-800/50 rounded-lg border border-neutral-700">
              <div className="flex items-center gap-2">
                <span className="w-6 h-6 rounded-full bg-neutral-700 flex items-center justify-center text-xs">
                  {chunk.order}
                </span>
                <span className="font-medium text-white">{chunk.title}</span>
              </div>

              <p className="text-sm text-neutral-400 mt-2">{chunk.description}</p>

              <div className="mt-3 grid grid-cols-2 gap-4 text-xs">
                <div>
                  <span className="text-neutral-500">Creates:</span>
                  <div className="mt-1 space-y-1">
                    {chunk.creates.map((item, j) => (
                      <div key={j} className="text-emerald-400">+ {item}</div>
                    ))}
                  </div>
                </div>
                <div>
                  <span className="text-neutral-500">Consumes:</span>
                  <div className="mt-1 space-y-1">
                    {chunk.consumes.map((item, j) => (
                      <div key={j} className="text-blue-400">â† {item}</div>
                    ))}
                    {chunk.consumes.length === 0 && (
                      <div className="text-neutral-600">(none)</div>
                    )}
                  </div>
                </div>
              </div>

              {chunk.dependsOn.length > 0 && (
                <div className="mt-2 text-xs">
                  <span className="text-neutral-500">Depends on: </span>
                  <span className="text-neutral-400">
                    Chunk {chunk.dependsOn.join(', Chunk ')}
                  </span>
                </div>
              )}
            </div>
          ))}
        </div>
      </CollapsibleSection>

      {/* Actions */}
      <div className="flex items-center justify-between pt-4 border-t border-neutral-800">
        <button
          onClick={onBack}
          className="px-4 py-2 text-sm text-neutral-400 hover:text-white"
        >
          â† Back to Refine
        </button>
        <button
          onClick={onApprove}
          disabled={hasErrors}
          className={`px-4 py-2 text-sm rounded-lg ${
            hasErrors
              ? 'bg-neutral-700 text-neutral-500 cursor-not-allowed'
              : 'bg-emerald-600 hover:bg-emerald-500 text-white'
          }`}
        >
          {hasErrors ? 'Fix Errors to Continue' : 'Approve Contract â†’'}
        </button>
      </div>
    </div>
  );
}
```

## 4. API Endpoints

### POST /api/specs/[id]/contract/generate

```typescript
export async function POST(request: Request, context: RouteContext) {
  const { id: specId } = await context.params;

  const spec = getSpec(specId);
  if (!spec) {
    return NextResponse.json({ error: 'Spec not found' }, { status: 404 });
  }

  const project = getProject(spec.projectId);
  if (!project) {
    return NextResponse.json({ error: 'Project not found' }, { status: 404 });
  }

  // Gather project context
  const existingExports = await gatherExistingExports(project.directory);
  const existingFiles = await gatherExistingFiles(project.directory);

  // Generate contract with Opus
  const contractJson = await generateContract(spec.content, {
    workingDir: project.directory,
    existingExports,
    existingFiles
  });

  const contract: SpecContract = JSON.parse(contractJson);
  contract.specId = specId;
  contract.generatedAt = new Date().toISOString();
  contract.version = '1.0';

  // Run feasibility check
  const checker = new FeasibilityChecker(project.directory);
  contract.feasibility = await checker.check(contract);

  return NextResponse.json({ contract });
}
```

### POST /api/specs/[id]/contract/approve

```typescript
export async function POST(request: Request, context: RouteContext) {
  const { id: specId } = await context.params;
  const { contract } = await request.json();

  // Validate contract has no errors
  if (contract.feasibility?.issues.some(i => i.severity === 'error')) {
    return NextResponse.json(
      { error: 'Cannot approve contract with errors' },
      { status: 400 }
    );
  }

  // Save contract to spec
  updateSpec(specId, {
    contract: JSON.stringify(contract),
    contractApprovedAt: new Date().toISOString()
  });

  // Generate chunks from contract
  const chunks = await generateChunksFromContract(specId, contract);

  return NextResponse.json({ success: true, chunks });
}
```

---

# Roadmap Implementation

## Contract Editing UI (P1)

Full CRUD interface for editing contract before approval:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  EDIT CONTRACT                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  [+ Add Type] [+ Add File] [+ Add Chunk]                       â”‚
â”‚                                                                 â”‚
â”‚  Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚ HealthCheckResult                         [Edit] [Delete]   â”‚
â”‚  â”‚ interface HealthCheckResult {                               â”‚
â”‚  â”‚   healthy: boolean;                                         â”‚
â”‚  â”‚   dependencies: HealthCheckDependency[];                    â”‚
â”‚  â”‚ }                                                           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚                                                                 â”‚
â”‚  Chunks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚  [Drag to reorder - dependencies auto-update]                  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Dependency Graph Visualization (P1)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  DEPENDENCY GRAPH                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                   â”‚
â”‚         â”‚  1. Create Types  â”‚                                   â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â”‚                   â”‚                                             â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                   â”‚
â”‚         â”‚  2. Health Logic  â”‚                                   â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â”‚                   â”‚                                             â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                   â”‚
â”‚         â”‚  3. UI Component  â”‚                                   â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â”‚                   â”‚                                             â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                   â”‚
â”‚         â”‚  4. Integration   â”‚                                   â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Contract Amendments (P2)

When a chunk fails repeatedly or discovers it needs something not in the contract:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âš ï¸ CONTRACT AMENDMENT PROPOSED                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Chunk 2 discovered: checkHealth needs options parameter        â”‚
â”‚                                                                 â”‚
â”‚  PROPOSED CHANGE:                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚ functions[0].signature                                      â”‚
â”‚  â”‚                                                             â”‚
â”‚  â”‚ - (): Promise<HealthCheckResult>                            â”‚
â”‚  â”‚ + (options?: HealthCheckOptions): Promise<HealthCheckResult>â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚                                                                 â”‚
â”‚  ADDITIONAL TYPE NEEDED:                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚ + interface HealthCheckOptions {                            â”‚
â”‚  â”‚ +   timeout?: number;                                       â”‚
â”‚  â”‚ +   verbose?: boolean;                                      â”‚
â”‚  â”‚ + }                                                         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚                                                                 â”‚
â”‚  AFFECTS:                                                       â”‚
â”‚  â€¢ Chunk 3: Create HealthPanel component (uses checkHealth)    â”‚
â”‚  â€¢ Chunk 4: Integration (calls checkHealth)                    â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Accept Amendment    â”‚  â”‚  Reject & Fail Chunk            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# Generalization Layer

This section defines how the contract system can work beyond Specwright for any multi-agent workflow.

## 1. Generic Resource Model

Define a `ContractResource` interface that generalizes beyond code files:

```typescript
/**
 * Generic resource that can be created, consumed, or validated in any workflow.
 * Generalizes beyond code files to support data, messages, artifacts, etc.
 */
export interface ContractResource {
  id: string;                          // Unique identifier (e.g., "res_healthcheck_type")
  type: ResourceType;                  // Resource category
  schema?: JSONSchema;                 // Expected shape for data resources
  location?: string;                   // Path, URL, key - where it lives
  format?: string;                     // json, typescript, text, binary, etc.
  metadata?: Record<string, unknown>;  // Protocol-specific extensions
}

/**
 * Built-in resource types. Protocols can define custom types.
 */
export type ResourceType =
  | 'file'       // Source code, config files
  | 'data'       // Structured data (JSON, DB records)
  | 'message'    // Inter-agent messages
  | 'artifact'   // Build outputs, generated assets
  | string;      // Custom types (e.g., "slack_channel", "github_pr")

/**
 * JSON Schema type for validation
 */
export interface JSONSchema {
  type?: string;
  properties?: Record<string, JSONSchema>;
  required?: string[];
  items?: JSONSchema;
  [key: string]: unknown;  // Full JSON Schema support
}
```

### Mapping Current Types to ContractResource

Current `ContractFile` and `ContractType` map to this generic model:

```typescript
// ContractType â†’ ContractResource
const typeAsResource: ContractResource = {
  id: 'type_HealthCheckResult',
  type: 'file',
  location: 'packages/shared/src/types.ts',
  format: 'typescript',
  metadata: {
    exportName: 'HealthCheckResult',
    exportedFrom: '@specwright/shared',
    definition: 'interface HealthCheckResult { ... }'
  }
};

// ContractFile â†’ ContractResource
const fileAsResource: ContractResource = {
  id: 'file_health_check_ts',
  type: 'file',
  location: 'packages/dashboard/src/lib/health-check.ts',
  format: 'typescript',
  metadata: {
    action: 'create',
    purpose: 'Health check implementation',
    exports: ['checkHealth', 'HealthChecker']
  }
};

// Data resource example (non-code)
const dataResource: ContractResource = {
  id: 'data_research_findings',
  type: 'data',
  location: 'outputs/research.json',
  format: 'json',
  schema: {
    type: 'object',
    properties: {
      findings: { type: 'array' },
      summary: { type: 'string' }
    },
    required: ['findings', 'summary']
  }
};
```

## 2. Agent-Agnostic Contract Format

Define `AgentContract` as the portable, protocol-independent format:

```typescript
/**
 * Agent-agnostic contract format.
 * Can be used by any multi-agent system regardless of underlying protocol.
 */
export interface AgentContract {
  version: string;                     // Schema version "1.0"
  id: string;                          // Unique contract ID
  protocol?: string;                   // Source protocol (specwright, a2a, mcp, langchain)

  steps: ContractStep[];               // Execution steps (generalized from chunks)
  resources: ContractResource[];       // Registry of all resources
  validators: ValidatorConfig[];       // Which validators to use

  metadata?: {
    generatedAt?: string;              // ISO timestamp
    generatedBy?: string;              // Agent/system that generated this
    [key: string]: unknown;
  };
}

/**
 * Generalized execution step (derived from ContractChunk).
 * Represents work to be done by an agent.
 */
export interface ContractStep {
  id: string;                          // Unique step ID
  agent: string;                       // Who executes (not just "chunk executor")
  description: string;                 // What needs to be done

  creates: string[];                   // Resource IDs this step produces
  consumes: string[];                  // Resource IDs this step needs
  dependsOn: string[];                 // Step IDs that must complete first

  assertions: ContractAssertion[];     // Requirements for this step

  metadata?: {
    order?: number;                    // For ordered execution
    timeout?: number;                  // Max execution time
    retries?: number;                  // Max retry attempts
    [key: string]: unknown;
  };
}

/**
 * Validator configuration for contract enforcement
 */
export interface ValidatorConfig {
  type: string;                        // Validator type (see ORC-62)
  resourceTypes: string[];             // Which resource types this validates
  options?: Record<string, unknown>;   // Validator-specific options
}
```

## 3. Contract Serialization

Contracts should be serializable to:

- **JSON** (primary) - For APIs, storage, and programmatic access
- **YAML** (secondary) - For human-readable config files

### JSON Example: Research Workflow

A non-coding use case with multiple agents:

```json
{
  "version": "1.0",
  "id": "contract_research_synthesis",
  "protocol": "langchain",

  "resources": [
    {
      "id": "res_query",
      "type": "message",
      "format": "text",
      "metadata": { "source": "user_input" }
    },
    {
      "id": "res_sources",
      "type": "data",
      "format": "json",
      "schema": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "url": { "type": "string" },
            "content": { "type": "string" },
            "relevance": { "type": "number" }
          }
        }
      }
    },
    {
      "id": "res_synthesis",
      "type": "artifact",
      "format": "markdown",
      "location": "outputs/synthesis.md"
    }
  ],

  "steps": [
    {
      "id": "step_search",
      "agent": "web_search_agent",
      "description": "Search for relevant sources based on query",
      "creates": ["res_sources"],
      "consumes": ["res_query"],
      "dependsOn": [],
      "assertions": [
        {
          "type": "assert",
          "condition": "sources found",
          "message": "Must find at least 3 relevant sources",
          "check": {
            "type": "schema_match",
            "target": "res_sources"
          }
        }
      ]
    },
    {
      "id": "step_analyze",
      "agent": "analysis_agent",
      "description": "Analyze and synthesize findings",
      "creates": ["res_synthesis"],
      "consumes": ["res_sources"],
      "dependsOn": ["step_search"],
      "assertions": [
        {
          "type": "assert",
          "condition": "synthesis complete",
          "message": "Synthesis must include summary and citations",
          "check": {
            "type": "pattern_match",
            "target": "res_synthesis",
            "pattern": "## Summary[\\s\\S]+## Citations"
          }
        }
      ]
    }
  ],

  "validators": [
    { "type": "json-schema", "resourceTypes": ["data"] },
    { "type": "exists", "resourceTypes": ["*"] }
  ]
}
```

### YAML Equivalent

```yaml
version: "1.0"
id: contract_research_synthesis
protocol: langchain

resources:
  - id: res_query
    type: message
    format: text

  - id: res_sources
    type: data
    format: json
    schema:
      type: array
      items:
        type: object
        properties:
          url: { type: string }
          content: { type: string }

steps:
  - id: step_search
    agent: web_search_agent
    description: Search for relevant sources
    creates: [res_sources]
    consumes: [res_query]
    dependsOn: []
```

## 4. Protocol Adapter Interface

Define the interface that protocol-specific adapters must implement:

```typescript
/**
 * Adapter for converting between protocol-specific formats and AgentContract.
 * Each supported protocol implements this interface.
 */
export interface ProtocolAdapter<TWorkflow = unknown, TOutput = unknown> {
  /** Protocol identifier (e.g., "specwright", "a2a", "mcp", "langchain") */
  protocol: string;

  /**
   * Convert protocol-specific workflow definition to AgentContract.
   * @param workflow - The protocol's native workflow format
   * @returns Standardized AgentContract
   */
  toContract(workflow: TWorkflow): AgentContract;

  /**
   * Convert AgentContract back to protocol-specific format.
   * @param contract - Standardized AgentContract
   * @returns Protocol's native workflow format
   */
  fromContract(contract: AgentContract): TWorkflow;

  /**
   * Extract resources from agent/step output.
   * Called after each step to discover what was created.
   * @param output - The raw output from agent execution
   * @returns Resources that were created/modified
   */
  extractResources(output: TOutput): ContractResource[];
}

/**
 * Specwright's implementation of ProtocolAdapter.
 * Converts between SpecContract and AgentContract.
 */
export class SpecwrightAdapter implements ProtocolAdapter<SpecContract, ChunkOutput> {
  protocol = 'specwright';

  toContract(spec: SpecContract): AgentContract {
    // Convert SpecContract.types/files/chunks â†’ resources/steps
    const resources: ContractResource[] = [
      ...spec.types.map(t => this.typeToResource(t)),
      ...spec.files.map(f => this.fileToResource(f))
    ];

    const steps: ContractStep[] = spec.chunks.map(c => ({
      id: `chunk_${c.order}`,
      agent: 'glm_executor',
      description: c.description,
      creates: c.creates,
      consumes: c.consumes,
      dependsOn: c.dependsOn.map(d => `chunk_${d}`),
      assertions: c.assertions,
      metadata: { order: c.order, title: c.title }
    }));

    return {
      version: spec.version,
      id: `contract_${spec.specId}`,
      protocol: 'specwright',
      resources,
      steps,
      validators: [
        { type: 'file-export', resourceTypes: ['file'] },
        { type: 'exists', resourceTypes: ['*'] }
      ]
    };
  }

  fromContract(contract: AgentContract): SpecContract {
    // Convert back to SpecContract for Specwright execution
    // ...implementation
  }

  extractResources(output: ChunkOutput): ContractResource[] {
    // Parse git diff and find created exports
    // ...implementation
  }

  private typeToResource(type: ContractType): ContractResource {
    return {
      id: `type_${type.name}`,
      type: 'file',
      location: type.file,
      format: 'typescript',
      metadata: {
        exportName: type.name,
        exportedFrom: type.exportedFrom,
        definition: type.definition
      }
    };
  }

  private fileToResource(file: ContractFile): ContractResource {
    return {
      id: `file_${file.path.replace(/[\/\.]/g, '_')}`,
      type: 'file',
      location: file.path,
      format: file.path.endsWith('.ts') ? 'typescript' : 'unknown',
      metadata: {
        action: file.action,
        purpose: file.purpose,
        exports: file.exports
      }
    };
  }
}
```

### Adapter Registry

```typescript
/**
 * Registry for protocol adapters.
 * Allows runtime registration of new protocol support.
 */
export interface AdapterRegistry {
  register<T, O>(adapter: ProtocolAdapter<T, O>): void;
  get(protocol: string): ProtocolAdapter | undefined;
  list(): string[];
}

// Usage
const registry: AdapterRegistry = createAdapterRegistry();
registry.register(new SpecwrightAdapter());
registry.register(new A2AAdapter());  // Future: Google's A2A protocol
registry.register(new MCPAdapter());  // Future: MCP server protocol
```

## 5. Backward Compatibility

This generalization is **additive**, not breaking:

| Aspect | Status |
|--------|--------|
| All existing ORC-61 types | **Unchanged** - `ContractType`, `ContractFile`, `ContractChunk`, `SpecContract` work exactly as before |
| SpecContract | **Extends** AgentContract conceptually (can be converted via adapter) |
| Current implementation | **Becomes** `SpecwrightAdapter` - no changes to existing code paths |
| New protocols | **Opt-in** - Implement `ProtocolAdapter` to add support |
| Database schema | **No changes** - Generalization is in-memory/at-boundary |

### Migration Path

1. **Phase 1 (MVP)**: Implement Specwright as-is with current types
2. **Phase 2 (Roadmap)**: Add `AgentContract` and `SpecwrightAdapter`
3. **Phase 3 (Future)**: Implement additional protocol adapters

### Protocol Adapter Details

Implementation details for protocol-specific adapters (A2A, MCP, LangChain) are specified in **ORC-63: Protocol Adapter System** (future spec).

Validation layer extensions for generic resources are specified in **ORC-62: DSPy-Style Assertion Enforcement System**.

---

# Acceptance Criteria

## MVP

- [ ] SpecContract type defined in shared package
- [ ] Database migration adds contract/creates/consumes/dependsOn columns
- [ ] Contract generation prompt produces valid contracts
- [ ] Feasibility checker validates consumes exist (grep-based)
- [ ] Feasibility checker catches dependency order issues
- [ ] Contract review UI shows types, files, chunks
- [ ] Feasibility issues shown inline with warnings/errors
- [ ] Cannot approve contract with errors
- [ ] Contract approval generates chunks with proper dependencies
- [ ] Chunks include creates/consumes/dependsOn fields

## Roadmap

- [ ] Contract editing UI (add/edit/delete types, files, chunks)
- [ ] Dependency graph visualization
- [ ] Progressive disclosure (collapsed by default, expand details)
- [ ] Contract amendment proposals
- [ ] Amendment acceptance updates contract and affected chunks
- [ ] Contract templates for common patterns
- [ ] Contract diffing on regenerate
